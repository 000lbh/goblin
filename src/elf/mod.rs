//! Access ELF constants, other helper functions, which are independent of ELF bithood.  Also
//! provides [`parse`](fn.parse.html) which returns a wrapped `Elf64` or `Elf32` binary.
//!
//! To access the contents of the binary, instead of directly getting the struct fields, you call
//! the similarly named methods.
//!
//! # Example
//!
//! ```rust, no_run
//! use std::fs::File;
//!
//! pub fn read (fd: &mut File) {
//!   match goblin::elf::parse(fd) {
//!     Ok(binary) => {
//!       let entry = binary.entry();
//!       for ph in binary.program_headers() {
//!         if ph.p_type() == goblin::elf::program_header::PT_LOAD {
//!           let mut _buf = vec![0u8; ph.p_filesz() as usize];
//!           // read responsibly
//!          }
//!       }
//!     },
//!     Err(_) => ()
//!   }
//! }
//! ```
//!
//! This will properly access the underlying 32-bit or 64-bit binary automatically. Note that since
//! 32-bit binaries typically have shorter 32-bit values in some cases (specifically for addresses and pointer
//! values), these values are upcasted to u64/i64s when appropriate.
//!
//! See [goblin::elf::Binary](enum.Binary.html) for more information.
//!
//! You are still free to use the specific 32-bit or 64-bit versions by accessing them through `goblin::elf64`, etc.
//!
//! # Note
//! To use the automagic ELF datatype union parser, you _must_ enable/opt-in to the  `elf64`, `elf32`, and
//! `endian_fd` features if you disable `default`.

#[cfg(feature = "std")]
pub mod strtab;

// These are shareable values for the 32/64 bit implementations.
//
// They are publicly re-exported by the pub-using module
#[macro_use]
pub mod header;
#[macro_use]
pub mod program_header;
#[macro_use]
pub mod section_header;
#[macro_use]
pub mod sym;
#[macro_use]
pub mod dyn;
#[macro_use]
pub mod rela;

#[cfg(all(feature = "std", feature = "elf32", feature = "elf64", feature = "endian_fd"))]
pub use self::impure::*;

#[cfg(all(feature = "std", feature = "elf32", feature = "elf64", feature = "endian_fd"))]
#[macro_use]
mod impure {

    use std::io::{self, Read, Seek};
    use std::vec;

    use super::header;

    use elf32;
    use elf64;

    macro_rules! wrap {
        ($list:ident, $name:ident, @optvec $elem:ident) => {
            #[derive(Debug)]
            pub enum $list {
                Elf32(Option<Vec<elf32::$elem::$name>>),
                Elf64(Option<Vec<elf64::$elem::$name>>),
            }
        };
        ($list:ident, $name:ident, @vec $elem:ident) => {
            #[derive(Debug)]
            pub enum $list {
                Elf32(Vec<elf32::$elem::$name>),
                Elf64(Vec<elf64::$elem::$name>),
            }
        };
        ($name:ident, $elem:ident) => {
            #[derive(Debug)]
            pub enum $name {
                Elf32(elf32::$elem::$name),
                Elf64(elf64::$elem::$name),
            }
        };
    }

    wrap!(ProgramHeader, program_header);
    wrap!(SectionHeader, section_header);
    wrap!(Header, header);
    wrap!(Sym, sym);
    wrap!(Dyn, dyn);
    wrap!(Rela, rela);

    wrap!(ProgramHeaders, ProgramHeader, @vec program_header);
    wrap!(SectionHeaders, SectionHeader, @vec section_header);
    wrap!(Dynsyms, Sym, @vec sym);
    wrap!(Syms, Sym, @vec sym);
    wrap!(Relas, Rela, @vec rela);
    wrap!(Pltrelas, Rela, @vec rela);
    wrap!(Dynamic, Dyn, @vec dyn);

    macro_rules! wrap_iterator {
      ($container:ident, $elem:ident) => {
         impl IntoIterator for $container {
            type Item = $elem;
            type IntoIter = vec::IntoIter<$elem>;
            fn into_iter(self) -> Self::IntoIter {
                match self {
                    $container::Elf32(container) => {
                        let elems: Vec<$elem> = container.into_iter().map(|elem| $elem::Elf32(elem)).collect();
                        elems.into_iter()
                    }
                    $container::Elf64(container) => {
                        let elems: Vec<$elem> = container.into_iter().map(|elem| $elem::Elf64(elem)).collect();
                        elems.into_iter()
                    }
                }
            }
        }
      }
    }

    wrap_iterator!(ProgramHeaders, ProgramHeader);
    wrap_iterator!(SectionHeaders, SectionHeader);
    wrap_iterator!(Syms, Sym);
    wrap_iterator!(Relas, Rela);
    wrap_iterator!(Dynamic, Dyn);

    macro_rules! get_field {
      ($name:ident, $field:ident, $cast:ty) => {
        pub fn $field(&self) -> $cast {
          match self {
            &$name::Elf32(ref st) => st.$field as $cast,
            &$name::Elf64(ref st) => st.$field as $cast,
          }
        }
      };
    }

    macro_rules! wrap_impl {
        ($name:ident, $elem:ident, [$(($field:ident, $typ:ty)),*]) => {
            impl $name {
                $(
                  get_field!($name, $field, $typ);
                )*
            }
        }
    }

    wrap_impl!(Header, header, [
    (e_ident, [u8; header::SIZEOF_IDENT]),
    (e_type, u16),
    (e_machine, u16),
    (e_version, u32),
    (e_entry, u64),
    (e_phoff, u64),
    (e_shoff, u64),
    (e_flags, u32),
    (e_ehsize, u16),
    (e_phentsize, u16),
    (e_phnum, u16),
    (e_shentsize, u16),
    (e_shnum, u16),
    (e_shstrndx, u16)
    ]);
    wrap_impl!(ProgramHeader, program_header, [
    (p_type, u32),
    (p_flags, u32),
    (p_offset, u64),
    (p_vaddr, u64),
    (p_paddr, u64),
    (p_filesz, u64),
    (p_memsz, u64),
    (p_align, u64)
    ]);
    wrap_impl!(SectionHeader, section_header, [
    (sh_name, u32),
    (sh_type, u32),
    (sh_flags, u64),
    (sh_addr, u64),
    (sh_offset, u64),
    (sh_size, u64),
    (sh_link, u32),
    (sh_info, u32),
    (sh_addralign, u64),
    (sh_entsize, u64)
    ]);
    wrap_impl!(Sym, sym, [
    (st_name, usize),
    (st_info, u8),
    (st_other, u8),
    (st_shndx, u16),
    (st_value, u64),
    (st_size, u64)
    ]);
    wrap_impl!(Dyn, dyn, [
    (d_tag, u64),
    (d_val, u64)
    ]);
    wrap_impl!(Rela, rela, [
    (r_offset, u64),
    (r_info, u64),
    (r_addend, u64)
    ]);

    // this is a hack cause don't feel like messing with macros
    impl Sym {
        pub fn is_function(&self) -> bool {
          match self {
            &Sym::Elf32(ref st) => st.is_function(),
            &Sym::Elf64(ref st) => st.is_function(),
          }
        }
        pub fn is_import(&self) -> bool {
            match self {
                &Sym::Elf32(ref st) => st.is_import(),
                &Sym::Elf64(ref st) => st.is_import(),
            }
        }
    }

    #[derive(Debug)]
    pub enum Binary {
        Elf32(elf32::Binary),
        Elf64(elf64::Binary),
    }

    // TODO: fix this, clones the vector, when it's nicer to just send a reference back and let callee
    // decide if they want to clone
    macro_rules! get_collection {
        ($name:ident, $memtyp:ident, $field:ident) => {
            pub fn $field(&self) -> $memtyp {
                match self {
                    &$name::Elf32(ref binary) => $memtyp::Elf32(binary.$field.clone()),
                    &$name::Elf64(ref binary) => $memtyp::Elf64(binary.$field.clone()),
                }
            }
        }
    }
    macro_rules! get_strtab {
          ($field:ident) => {
              pub fn $field<'a> (&'a self) -> &'a super::strtab::Strtab<'a> {
                match self {
                    &Binary::Elf32(ref binary) => &binary.$field,
                    &Binary::Elf64(ref binary) => &binary.$field,
                }
              }
          }
    }

    macro_rules! get_unwrapped_field {
          ($name:ident, $field:ident, $typ:ty) => {
              pub fn $field (&self) -> &$typ {
                match self {
                    &Binary::Elf32(ref binary) => &binary.$field,
                    &Binary::Elf64(ref binary) => &binary.$field,
                }
              }
          }
    }

    impl Binary {
        get_field!(Binary, is_64, bool);
        get_field!(Binary, is_lib, bool);
        get_field!(Binary, entry, u64);
        get_field!(Binary, bias, u64);

        get_unwrapped_field!(Binary, soname, Option<String>);
        get_unwrapped_field!(Binary, interpreter, Option<String>);
        get_unwrapped_field!(Binary, libraries, Vec<String>);

        get_collection!(Binary, Header, header);
        get_collection!(Binary, ProgramHeaders, program_headers);
        get_collection!(Binary, Syms, dynsyms);
        get_collection!(Binary, Syms, syms);
        get_collection!(Binary, Relas, rela);
        get_collection!(Binary, Pltrelas, pltrela);

        get_strtab!(dynstrtab);
        get_strtab!(strtab);
        get_strtab!(shdr_strtab);

        pub fn dynamic (&self) -> Option<Dynamic> {
            match self {
                &Binary::Elf32(ref binary) => {
                    if let Some(ref dynamic) = binary.dynamic {
                        Some(Dynamic::Elf32(dynamic.clone()))
                    } else {
                        None
                    }
                },
                &Binary::Elf64(ref binary) => {
                    if let Some(ref dynamic) = binary.dynamic {
                        Some(Dynamic::Elf64(dynamic.clone()))
                    } else {
                        None
                    }
                }
            }
        }
    }

    pub fn parse<R: Read + Seek>(fd: &mut R) -> io::Result<Binary> {
        match try!(header::peek(fd)) {
            (header::ELFCLASS64, _is_lsb) => Ok(Binary::Elf64(try!(elf64::Binary::parse(fd)))),
            (header::ELFCLASS32, _is_lsb) => Ok(Binary::Elf32(try!(elf32::Binary::parse(fd)))),
            (class, is_lsb) => {
                io_error!("Unknown values in ELF ident header: class: {} is_lsb: {}",
                          class,
                          is_lsb)
            }
        }
    }
}

macro_rules! elf_from { ($intmax:expr) => {
    use std::path::Path;
    use std::fs::File;
    use std::io;
    use std::io::Read;
    use std::io::Seek;
    use std::io::SeekFrom::Start;

    use elf::strtab;
    use super::{header, program_header, section_header, dyn, sym, rela};

    #[derive(Debug)]
    pub struct Binary {
        pub header: header::Header,
        pub program_headers: Vec<program_header::ProgramHeader>,
        pub section_headers: Vec<section_header::SectionHeader>,
        pub shdr_strtab: strtab::Strtab<'static>,
        pub dynamic: Option<Vec<dyn::Dyn>>,
        pub dynsyms: Vec<sym::Sym>,
        pub dynstrtab: strtab::Strtab<'static>,
        pub syms: Vec<sym::Sym>,
        pub strtab: strtab::Strtab<'static>,
        pub rela: Vec<rela::Rela>,
        pub pltrela: Vec<rela::Rela>,
        pub soname: Option<String>,
        pub interpreter: Option<String>,
        pub libraries: Vec<String>,
        pub is_64: bool,
        pub is_lib: bool,
        pub entry: usize,
        pub bias: usize,
    }

    impl Binary {

        pub fn parse<R: Read + Seek> (fd: &mut R) -> io::Result<Binary> {
            let header = try!(header::Header::parse(fd));
            let entry = header.e_entry as usize;
            let is_lib = header.e_type == header::ET_DYN;
            let is_lsb = header.e_ident[header::EI_DATA] == header::ELFDATA2LSB;
            let is_64 = header.e_ident[header::EI_CLASS] == header::ELFCLASS64;

            let program_headers = try!(program_header::ProgramHeader::parse(fd, header.e_phoff as u64, header.e_phnum as usize, is_lsb));

            let dynamic = try!(dyn::parse(fd, &program_headers, is_lsb));
            let mut bias: usize = 0;
            for ph in &program_headers {
                if ph.p_type == program_header::PT_LOAD {
                    // this is an overflow hack that allows us to use virtual memory addresses
                    // as though they're in the file by generating a fake load bias which is then
                    // used to overflow the values in the dynamic array, and in a few other places
                    // (see Dyn::DynamicInfo), to generate actual file offsets; you may have to
                    // marinate a bit on why this works. i am unsure whether it works in every
                    // conceivable case. i learned this trick from reading too much dynamic linker
                    // C code (a whole other class of C code) and having to deal with broken older
                    // kernels on VMs. enjoi
                    bias = (($intmax - ph.p_vaddr).wrapping_add(1)) as usize;
                    break;
                }
            }

            let mut interpreter = None;
            for ph in &program_headers {
                if ph.p_type == program_header::PT_INTERP {
                    let mut bytes = vec![0u8; (ph.p_filesz - 1) as usize];
                    try!(fd.seek(Start(ph.p_offset as u64)));
                    try!(fd.read(&mut bytes));
                    interpreter = Some(String::from_utf8(bytes).unwrap())
                }
            }

            let section_headers = try!(section_header::SectionHeader::parse(fd, header.e_shoff as u64, header.e_shnum as usize, is_lsb));

            let mut syms = vec![];
            let mut strtab = strtab::Strtab::default();
            for shdr in &section_headers {
                if shdr.sh_type as u32 == section_header::SHT_SYMTAB {
                    let count = shdr.sh_size / shdr.sh_entsize;
                    syms = try!(sym::parse(fd, shdr.sh_offset as usize, count as usize, is_lsb))
                }
                if shdr.sh_type as u32 == section_header::SHT_STRTAB {
                    strtab = try!(strtab::Strtab::parse(fd, shdr.sh_offset as usize, shdr.sh_size as usize));
                }
            }

            let strtab_idx = header.e_shstrndx as usize;
            let shdr_strtab = if strtab_idx >= section_headers.len() {
                strtab::Strtab::default()
            } else {
                let shdr = &section_headers[strtab_idx];
                try!(strtab::Strtab::parse(fd, shdr.sh_offset as usize, shdr.sh_size as usize))
            };

            let mut soname = None;
            let mut libraries = vec![];
            let mut dynsyms = vec![];
            let mut rela = vec![];
            let mut pltrela = vec![];
            let mut dynstrtab = strtab::Strtab::default();
            if let Some(ref dynamic) = dynamic {
                let dyn_info = dyn::DynamicInfo::new(&dynamic, bias); // we explicitly overflow the values here with our bias
                dynstrtab = try!(strtab::Strtab::parse(fd,
                                                          dyn_info.strtab,
                                                          dyn_info.strsz));

                if dyn_info.soname != 0 {
                    soname = Some(dynstrtab.get(dyn_info.soname).to_owned())
                }
                if dyn_info.needed_count > 0 {
                    let needed = unsafe { dyn::get_needed(dynamic, &dynstrtab, dyn_info.needed_count)};
                    libraries = Vec::with_capacity(dyn_info.needed_count);
                    for lib in needed {
                        libraries.push(lib.to_owned());
                    }
                }

                let num_syms = (dyn_info.strtab - dyn_info.symtab) / dyn_info.syment;
                dynsyms = try!(sym::parse(fd, dyn_info.symtab, num_syms, is_lsb));
                rela = try!(rela::parse(fd, dyn_info.rela, dyn_info.relasz, is_lsb));
                pltrela = try!(rela::parse(fd, dyn_info.jmprel, dyn_info.pltrelsz, is_lsb));
            }

            let elf = Binary {
                header: header,
                program_headers: program_headers,
                section_headers: section_headers,
                shdr_strtab: shdr_strtab,
                dynamic: dynamic,
                dynsyms: dynsyms,
                dynstrtab: dynstrtab,
                syms: syms,
                strtab: strtab,
                rela: rela,
                pltrela: pltrela,
                soname: soname,
                interpreter: interpreter,
                libraries: libraries,
                is_64: is_64,
                is_lib: is_lib,
                entry: entry,
                bias: bias,
            };

            Ok(elf)
        }

        pub fn from_path(path: &Path) -> io::Result<Binary> {
            let mut fd = try!(File::open(&path));
            let metadata = try!(fd.metadata());
            if metadata.len() < header::SIZEOF_EHDR as u64 {
                io_error!("Error: {:?} size is smaller than an ELF header", path.as_os_str())
            } else {
                Self::parse(&mut fd)
            }
        }
    }
};}

#[cfg(test)]
mod tests {
    use super::*;

    use std::io::Cursor;

    #[test]
    fn endian_parse() {
        let crt1: Vec<u8> = vec![0x7F,0x45,0x4C,0x46,0x2,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x3E,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0xE,0x0,0xB,0x0,0x4,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x47,0x4E,0x55,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x6,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x31,0xED,0x49,0x89,0xD1,0x5E,0x48,0x89,0xE2,0x48,0x83,0xE4,0xF0,0x50,0x54,0x49,0xC7,0xC0,0x0,0x0,0x0,0x0,0x48,0xC7,0xC1,0x0,0x0,0x0,0x0,0x48,0xC7,0xC7,0x0,0x0,0x0,0x0,0xFF,0x15,0x0,0x0,0x0,0x0,0xF4,0x0,0x1,0x0,0x2,0x0,0x14,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x7A,0x52,0x0,0x1,0x78,0x10,0x1,0x1B,0xC,0x7,0x8,0x90,0x1,0x7,0x10,0x14,0x0,0x0,0x0,0x1C,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2B,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x47,0x43,0x43,0x3A,0x20,0x28,0x47,0x4E,0x55,0x29,0x20,0x36,0x2E,0x31,0x2E,0x31,0x20,0x32,0x30,0x31,0x36,0x30,0x38,0x30,0x32,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x9,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0xA,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x4,0x0,0xF1,0xFF,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x65,0x0,0x0,0x0,0x12,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2B,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5A,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x61,0x0,0x0,0x0,0x20,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x28,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3E,0x0,0x0,0x0,0x11,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4D,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5F,0x0,0x0,0x0,0x10,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x69,0x6E,0x69,0x74,0x2E,0x63,0x0,0x5F,0x5F,0x6C,0x69,0x62,0x63,0x5F,0x63,0x73,0x75,0x5F,0x66,0x69,0x6E,0x69,0x0,0x5F,0x5F,0x6C,0x69,0x62,0x63,0x5F,0x63,0x73,0x75,0x5F,0x69,0x6E,0x69,0x74,0x0,0x5F,0x47,0x4C,0x4F,0x42,0x41,0x4C,0x5F,0x4F,0x46,0x46,0x53,0x45,0x54,0x5F,0x54,0x41,0x42,0x4C,0x45,0x5F,0x0,0x5F,0x49,0x4F,0x5F,0x73,0x74,0x64,0x69,0x6E,0x5F,0x75,0x73,0x65,0x64,0x0,0x5F,0x5F,0x6C,0x69,0x62,0x63,0x5F,0x73,0x74,0x61,0x72,0x74,0x5F,0x6D,0x61,0x69,0x6E,0x0,0x5F,0x5F,0x64,0x61,0x74,0x61,0x5F,0x73,0x74,0x61,0x72,0x74,0x0,0x0,0x0,0x0,0x0,0x12,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xB,0x0,0x0,0x0,0xA,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x19,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xB,0x0,0x0,0x0,0xC,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xB,0x0,0x0,0x0,0xD,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x26,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x29,0x0,0x0,0x0,0x11,0x0,0x0,0x0,0xFC,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2E,0x73,0x79,0x6D,0x74,0x61,0x62,0x0,0x2E,0x73,0x74,0x72,0x74,0x61,0x62,0x0,0x2E,0x73,0x68,0x73,0x74,0x72,0x74,0x61,0x62,0x0,0x2E,0x6E,0x6F,0x74,0x65,0x2E,0x41,0x42,0x49,0x2D,0x74,0x61,0x67,0x0,0x2E,0x72,0x65,0x6C,0x61,0x2E,0x74,0x65,0x78,0x74,0x0,0x2E,0x72,0x6F,0x64,0x61,0x74,0x61,0x2E,0x63,0x73,0x74,0x34,0x0,0x2E,0x72,0x65,0x6C,0x61,0x2E,0x65,0x68,0x5F,0x66,0x72,0x61,0x6D,0x65,0x0,0x2E,0x64,0x61,0x74,0x61,0x0,0x2E,0x62,0x73,0x73,0x0,0x2E,0x63,0x6F,0x6D,0x6D,0x65,0x6E,0x74,0x0,0x2E,0x6E,0x6F,0x74,0x65,0x2E,0x47,0x4E,0x55,0x2D,0x73,0x74,0x61,0x63,0x6B,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1B,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2E,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2B,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x29,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x60,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xC,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x34,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x12,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8C,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x46,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x90,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x41,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x78,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xC,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x50,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xC0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x56,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xC4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5B,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xC4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1B,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x64,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xDF,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x90,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x74,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xE0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xC8,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0xD,0x0,0x0,0x0,0xA,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xA8,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x6C,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,];
        let mut cursor = Cursor::new(crt1);
        match parse(&mut cursor) {
            Ok (binary) => {
                assert!(binary.is_64());
                assert!(!binary.is_lib());
                assert_eq!(binary.entry(), 0);
                assert_eq!(binary.bias(), 0);
                let syms = binary.syms();
                let mut i = 0;
                for sym in syms {
                    if i == 11 {
                        let symtab = binary.strtab();
                        assert_eq!(&symtab[sym.st_name() as usize], "_start");
                        break;
                    }
                    i += 1;
                }
            },
            Err (_) => {
                assert!(false)
            }
        }
    }
}